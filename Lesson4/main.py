"""
    Срезы (slices) - это штука, благодаря которой мы можем брать
    только часть списка (строки), то есть "срезать" его.
    Примеры:
"""

a = [1, 6, 4, 8, 5, 8, 0]
print(a[1:4])  # слева от двоеточия - элемент, который мы хотим взять первым, справа - последним (не влючительно)
# Вывод: [6, 4, 8]
# Можно также добавить шаг, с которым мы хотим брать элементы:

print(a[1:4:2])  # Вывод: [6, 8] - мы берём элементы через один (так как указан шаг 2)
print(a[:4])  # Можно оставить начальный или конечный элементы пустыми, тогда мы будем
# брать список или строкус самого начала или конца
# Вывод примера сверху: [1, 6, 4, 8]

# Шаг также может быть отрицательным, но при этом сначала нужно указывать конечный элемент, а затем
# начальный:

print(a[4:1:-1])  # Вывод: [5, 8, 4]
print(a[::-1])  # А так можно развернуть список (строку) целиком: [0, 8, 5, 8, 4, 6, 1]

# Ещё пример:

a = "Всем привет!"
print(a[5:])  # Вывод: привет!
print(a[:4])  # Вывод: Всем


"""
    Списочные выражения - синтаксис языка, благодаря которому мы можем создавать списки
    в одну строку. Примеры:
"""
# Как бы мы делали раньше:
a = []  # Создали пустой список
for i in range(10):
    a.append(i)  # Добавляем в список значения от 0 до 9
print(a)  # Вывод: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

# С помощью списочных выражений:

a = [i for i in range(10)]  # Перед циклом пишем элемент, который нкжно добавлять (то, что внутри append
# сверху), а затем пишем цикл, сколько раз добавлять этот элемент
print(a)  # Вывод: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

a = [input() for i in range(int(input()))]  # Создаём список строк, которые вводит пользователь,
# из количества элементов, которое вводит пользователь

# Также можно добавлять условия в списочное выражение:

a = [i for i in range(1, 100) if i % 7 == 0]  # Создаём список из чисел от 1 до 99, которые делятся на 7

# Старая запись того, что сверху (для сравнения):

a = []
for i in range(1, 100):
    if i % 7 == 0:
        a.append(i)

# Фунция map(). Функия map() применит функцию, которая стоит у неё как первый аргумент к каждому
# элементу списка (строки или любой другой структуры данных). Примеры:

a = ['123', '312', '4567', '7665', '894']  # Список из чисел, которые представлены как строки
print(map(int, a))  # Применяем функцию int() к каждому элементу списка а
# Вывод: <map object at 0x000001D90FBFBEE0>

"""
    Вывод сверху означает, что у нас всё правильно отработало, просто это запись, которую мы
    не можем прочитать (если интересно, то это адрес ячейки памяти сгенерированного объекта map).
    Чтобы перевести запись сверху в "читабельную", нужно обернуть эту конструкцию в функцию list().
    Функция list() преобразует что-либо в список:
"""

print(list(map(int, a)))  # Вывод: [123, 312, 4567, 7665, 894] - теперь мы это можем прочитать,
# и все числа преобразовались из строк в сами числа.

print(list(map(float, a)))  # Вывод: [123.0, 312.0, 4567.0, 7665.0, 894.0] - так как мы ко всем
# элементам примениили функцию float(), и они преобразовались в дробные

"""
    Теперь вопрос: зачем кто-то будет записывать числа в виде строки? Такие случаи действительно
    бывают. Например, когда мы считываем данные из файла (даже числа) - они всегда будут в строковом виде.
"""

"""
    Считывание из файла. Чтобы считать данные из файла, нужно использовать функцию open().
    Допустим, у нас есть файл "test.txt". В первой строке у него записано сначала количество строк, а
    затем написано количество чисел в каждой строке. В каждой строке какие-то 2 числа. Попробуем считать
    их из файла:
"""

f = open("test.txt")  # Открыли файл и записали его в переменную f
# n, m = f.readline().split() - это строкой мы запишем в переменные n, m строки '3', '2'.
# Метод readline() считывает строку, а метод split() разделит её по пробелу на список. Однако без
# функции map() оба эти числа будут в виде строк, и мы ими не сможем нормально воспользоваться. Поэтому
# выражение сверху нужно обернуть в функцию map(), а первым параметром прописать функцию int():

n, m = map(int, f.readline().split())  # Теперь в переменной n лежит число 3, а в m - число 2

# Теперь будем считывать следующие строки и добавлять их в список:

sp = []
for i in range(n):
    sp.append(list(map(int, f.readline().split())))
print(sp)  # Вывод: [[123, 456], [33, 12], [78, 90]]

# Получился двумерный список, в каждом вложенном списке по 2 числа, которые мы считали - всё верно
# Однако эту запись можно сделать короче с помощью списочного выражения:

sp = [list(map(int, f.readline().split())) for i in range(n)]  # Вывод будет тот же самый

# Также нужно не забыть закрыть файл:

f.close()  # Если не закрыть маленький файл, как у нас, то ничего страшного не произойдёт,
# но если забыть закрыть большой файл, то компьютер может начать зависать.
# Также открывать файл можно с помощью конструкции with-as, тогда файл будет закрываться
# автоматически. Снизу сейчас напишу полностью программу считывания файла без with-a и с
# этой конструкцией (первый вариант - это то, что написано выше, но в нормальом виде и без комментариев):

f = open("test.txt")
n, m = map(int, f.readline().split())
sp = [list(map(int, f.readline().split())) for i in range(n)]
f.close()
print(sp)  # [[123, 456], [33, 12], [78, 90]]

# С with-as:

with open("test.txt") as f:
    n, m = map(int, f.readline().split())
    sp = [list(map(int, f.readline().split())) for i in range(n)]
print(sp)

"""
    Маленькие уточнения: после выхода из конструкции with-as файл закроется автоматически, и
    его не нужно закрывать самому. Под эту конструкцию нужно впихнуть любую строку, где используется
    переменная f, то есть наш файл.
    
    В функции open() можно написать просто имя файла, как у нас, то есть open("test.txt"), только
    тогда, когда файл находится в той же папке, что и программа, иначе нужно писать полный
    путь к файлу.
    
    В том месте, где мы задаём переменные n и m, мы не оборачиываем функциюю map() в функцию
    list(), поскольку мы не создаём список в это месте.
    
    На этом всё)
"""
