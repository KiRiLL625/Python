"""
    Объектно-ориентированное программирование в Python. Перед просмотром
    этого урока рекомендую вспомнить урок по ООП на Java
"""

# Чтобы создать класс, нужно написать слово "class", затем имя класса и двоеточие
# Также перед объявлением класса должен быть отступ в 2 строки, если это не начало файла.


class Animal:
    """
        Переменные класса пишутся так же, как и обычные. В питоне нет ключевых
        слов public, private, но ограничить доступ к переменной можно, если имя переменной
        начать с нижнего подчёркивания. То есть в питоне инкапсуляция (скрытие доступа к
        элементам класса) реализовывается на честном слове. Снизу записаны "приватные" переменные
        класса.
    """
    _name = "wasdgfhdgrfwedfsgdfnrfeqbg"
    _age = 0
    _color = "gray"

    # Конструктор класса (задаёт параметры при создании объекта) пишется здесь немного по-другому.
    # Он пишется как обычная функция, но при этом название всегда одно: __init__. Оно зарезервировано.
    # Также в качестве первого параметра должно быть ключевое слово self.
    def __init__(self, name, age, color):
        self._name = name
        self._age = age
        self._color = color

    # Методы (функции) класса. Если они применяются к какому-то конкретному объекту, то
    # в качестве первого параметра они должны также иметь ключевое слово self. В данном
    # случае мы создали метод, который меняет имя нашему животному.
    def set_name(self, other_name):
        self._name = other_name

    # Метод get_name получает имя животного. То же самое с get_age и get_color
    def get_name(self):
        return self._name

    def get_age(self):
        return self._age

    def get_color(self):
        return self._color

    # Статичные методы, как и в Java и в любом другом языке, поддерживающем ООП применяют метод
    # ко всем объектам класса. Перед статичным методом должен стоять "декоратор" @staticmethod,
    # и метод не должен иметь параметра self.
    @staticmethod
    def tail():
        return "black"

    # Перегрузка оператора - штука, благодаря которой мы можем задавать свои правила арифметических
    # действий с объектами. Если это правило не задать, то интерпретатор просто не поймёт, как складывать
    # или вычитать наши объекты и просто выдаст ошибку, так как в классе может быть много
    # переменных и непонятно, что с каждой из них делать. Но если мы напишем специальную функцию, то
    # всё будет хорошо.

    # В данном случае функция __add__ (это тоже зарезервированное имя) даёт понять компилятору, как
    # складывать наши объекты. Здесь мы складываем животных по их возрасту
    def __add__(self, other):
        return self._age + other.get_age()

    # А здесь мы умножаем животных, также по возрасту
    def __mul__(self, other):
        return self._age * other.get_age()

# Чтобы указать класс-наследник, нужно после имени класса в скобках написать класс-родитель.
# Питон поддерживает множественное наследование, в Java можно было наследовать только один класс.


class Dog(Animal):
    pass  # Ключевое слово pass - просто заглушка, которая помогает интерпретировать код


animal1 = Animal("Chebyrashka", 1, "brown")  # создали объект класса Animal и записали в переменную animal1
age1 = animal1.get_age()  # в переменной age1 теперь лежит возраст объекта animal1, то есть 1
print(age1)  # вывод: 1
animal1._color = "green"  # здесь мы меняем приватную переменную переменную объекта animal1.
# Интерпретатор будет сильно ругаться на это, но всё же позволит это сделать, так как здесь
# всё на честном слове. Джава в таком случае просто не дала бы скомпилировать код
print(animal1._color)  # Вывод: green

dog1 = Dog("Bonny", 9, "red")  # Создали объект класса Dog. Он обладает теми же переменными
# и функциями, что и класс Animal, так как Dog - наследник Animal
dog2 = Dog("Mark", 10, "green")  # Создали второй объект класса Dog

print(dog1 + dog2)  # Сложили двух собачек, так как в классе Animal есть функция __add__. Вывод: 19
print(dog1 * dog2)  # Умножили двух собачек, так как есть функция __mul__. Вывод: 90

print(Animal.tail())  # Вывод: black. Здесь мы использовали статический метод класса Animal.
# Он вызывается через имя класса, а не имя объекта. Можно, конечно, вызвать и через имя объекта,
# но это не будет иметь никакого смысла, так как метод tail() - общий для всех членов класса - он статический

"""
    В основном, все зарезервированные имена функций в питоне начинаются с двух нижних подчёркиваний
    и заканчиваются также. Ключевое слово pass может использоваться также и для функций, чтобы
    их "пустое тело" просто интерпретировалось и не было никакой ошибки в коде.
"""
